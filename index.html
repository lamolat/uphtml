<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>üìö Tr√¨nh xem HTML Online</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
    }
    #controls {
      padding: 10px;
      background: #f0f0f0;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    select, button {
      padding: 5px;
      font-size: 14px;
    }
    #viewer {
      width: 100%;
      height: calc(100% - 60px);
      border: none;
    }
    #dropzone {
      border: 2px dashed #aaa;
      padding: 20px;
      text-align: center;
      margin: 10px;
      background: #fff;
      cursor: pointer;
      position: relative;
    }
    #pageInfo {
      font-weight: bold;
    }
    #fileInput {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .status {
      margin: 10px;
      padding: 10px;
      background: #f8f8f8;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="dropzone">
    <span>üìÇ K√©o & th·∫£ file HTML ho·∫∑c folder v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn file</span>
    <input type="file" id="fileInput" multiple webkitdirectory>
  </div>
  <div class="status" id="status">Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c t·∫£i l√™n</div>
  <div id="controls">
    <label>M√¥n h·ªçc:</label>
    <select id="subjectSelect"></select>

    <label>Trang:</label>
    <select id="pageSelect"></select>

    <button onclick="prevPage()">‚¨ÖÔ∏è</button>
    <button onclick="nextPage()">‚û°Ô∏è</button>
    
    <span id="pageInfo">Trang 0 / 0</span>
    <button onclick="downloadCombinedHTML()">üì• T·∫£i v·ªÅ to√†n b·ªô</button>
  </div>

  <iframe id="viewer"></iframe>

  <script>
    let data = {};
    let currentSubject = '';
    let currentPage = 1;

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const statusEl = document.getElementById('status');

    // X·ª≠ l√Ω s·ª± ki·ªán k√©o th·∫£
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.background = '#e0e0e0';
    });

    dropzone.addEventListener('dragleave', () => {
      dropzone.style.background = '#fff';
    });

    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.style.background = '#fff';
      handleDrop(e);
    });

    // X·ª≠ l√Ω khi click v√†o dropzone
    dropzone.addEventListener('click', (e) => {
      // NgƒÉn s·ª± ki·ªán click lan ƒë·∫øn file input
      if (e.target === dropzone || e.target.tagName === 'SPAN') {
        fileInput.click();
      }
    });

    function updateStatus() {
      const totalSubjects = Object.keys(data).length;
      let totalPages = 0;
      
      for (const subject in data) {
        totalPages += data[subject].length;
      }
      
      if (totalSubjects === 0) {
        statusEl.textContent = "Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c t·∫£i l√™n";
      } else {
        statusEl.textContent = `ƒê√£ t·∫£i l√™n ${totalSubjects} m√¥n h·ªçc v·ªõi t·ªïng c·ªông ${totalPages} trang`;
      }
    }

    function handleDrop(e) {
      const items = e.dataTransfer.items;
      if (!items) return;
      
      for (let i = 0; i < items.length; i++) {
        const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
        if (entry) {
          if (entry.isDirectory) {
            traverseDirectory(entry, entry.name);
          } else {
            const file = items[i].getAsFile();
            let subject = 'M·∫∑c ƒë·ªãnh';
            if (file.webkitRelativePath) {
              const parts = file.webkitRelativePath.split('/');
              if (parts.length > 1) subject = parts[0];
            }
            loadFile(file, subject);
          }
        }
      }
    }

    function traverseDirectory(entry, folderName) {
      const reader = entry.createReader();
      reader.readEntries(entries => {
        entries.forEach(ent => {
          if (ent.isFile && ent.name.endsWith('.html')) {
            ent.file(file => loadFile(file, folderName));
          } else if (ent.isDirectory) {
            traverseDirectory(ent, folderName);
          }
        });
      });
    }

    function loadFile(file, subject) {
      if (!file.name.endsWith('.html')) return;
      const reader = new FileReader();
      reader.onload = () => {
        if (!data[subject]) data[subject] = [];
        data[subject].push(reader.result);
        updateSubjects();
        updateStatus();
      };
      reader.readAsText(file);
    }

    function updateSubjects() {
      const subjectSelect = document.getElementById('subjectSelect');
      const currentValue = subjectSelect.value;
      subjectSelect.innerHTML = '';
      
      for (const subject in data) {
        const option = document.createElement('option');
        option.value = subject;
        option.textContent = subject;
        subjectSelect.appendChild(option);
      }
      
      if (currentValue && data[currentValue]) {
        subjectSelect.value = currentValue;
        currentSubject = currentValue;
      } else if (subjectSelect.options.length > 0) {
        currentSubject = subjectSelect.value;
      }
      
      loadPages();
    }

    function loadPages() {
      const pageSelect = document.getElementById('pageSelect');
      pageSelect.innerHTML = '';
      
      if (!data[currentSubject]) return;
      
      const pages = data[currentSubject];
      if (pages && pages.length > 0) {
        pages.forEach((_, i) => {
          const option = document.createElement('option');
          option.value = i + 1;
          option.textContent = (i + 1);
          pageSelect.appendChild(option);
        });
        currentPage = 1;
        updateViewer();
      }
    }

    function updateViewer() {
      if (!data[currentSubject] || data[currentSubject].length === 0) return;
      
      const html = data[currentSubject][currentPage - 1];
      const blob = new Blob([html], { type: 'text/html' });
      document.getElementById('viewer').src = URL.createObjectURL(blob);
      document.getElementById('pageSelect').value = currentPage;
      document.getElementById('pageInfo').textContent = "Trang " + currentPage + " / " + data[currentSubject].length;
    }

    document.getElementById('subjectSelect').onchange = () => {
      currentSubject = document.getElementById('subjectSelect').value;
      loadPages();
    };
    
    document.getElementById('pageSelect').onchange = () => {
      currentPage = parseInt(document.getElementById('pageSelect').value);
      updateViewer();
    };
    
    function prevPage() {
      if (currentPage > 1) {
        currentPage--;
        updateViewer();
      }
    }
    
    function nextPage() {
      if (currentPage < data[currentSubject].length) {
        currentPage++;
        updateViewer();
      }
    }
    
    function downloadCombinedHTML() {
      if (Object.keys(data).length === 0) {
        alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ t·∫£i v·ªÅ!');
        return;
      }

      // T·∫°o m·ªôt b·∫£n sao c·ªßa to√†n b·ªô d·ªØ li·ªáu, thay th·∫ø </script> ƒë·ªÉ tr√°nh l·ªói
      const allData = JSON.parse(JSON.stringify(data));
      const escapedData = JSON.stringify(allData).replace(/<\/script>/g, "<\\/script>");

      const html = `
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>T·ªïng h·ª£p t·∫•t c·∫£ m√¥n h·ªçc</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: sans-serif; }
    #controls { padding: 10px; background: #f0f0f0; display: flex; gap: 10px; flex-wrap: wrap; }
    select, button { padding: 5px; font-size: 14px; }
    #viewer { width: 100%; height: calc(100% - 60px); border: none; }
    #pageInfo { font-weight: bold; }
    .status { margin: 10px; padding: 10px; background: #f8f8f8; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="status" id="status">T·ªïng h·ª£p t·∫•t c·∫£ m√¥n h·ªçc</div>
  <div id="controls">
    <label>M√¥n h·ªçc:</label>
    <select id="subjectSelect"></select>
    <label>Trang:</label>
    <select id="pageSelect"></select>
    <button onclick="prevPage()">‚¨ÖÔ∏è</button>
    <button onclick="nextPage()">‚û°Ô∏è</button>
    <span id="pageInfo">Trang 0 / 0</span>
  </div>
  <iframe id="viewer"></iframe>
  <script>
    const data = ${escapedData};
    let currentSubject = '';
    let currentPage = 1;

    const subjectSelect = document.getElementById('subjectSelect');
    const pageSelect = document.getElementById('pageSelect');
    const viewer = document.getElementById('viewer');
    const pageInfo = document.getElementById('pageInfo');
    const statusEl = document.getElementById('status');

    function updateStatus() {
      const totalSubjects = Object.keys(data).length;
      let totalPages = 0;
      
      for (const subject in data) {
        totalPages += data[subject].length;
      }
      
      statusEl.textContent = \`T·ªïng h·ª£p \${totalSubjects} m√¥n h·ªçc v·ªõi \${totalPages} trang\`;
    }

    function loadSubjects() {
      subjectSelect.innerHTML = '';
      for (const subject in data) {
        const option = document.createElement('option');
        option.value = subject;
        option.textContent = subject;
        subjectSelect.appendChild(option);
      }
      if (subjectSelect.options.length > 0) {
        currentSubject = subjectSelect.value;
        loadPages();
      }
      updateStatus();
    }

    function loadPages() {
      pageSelect.innerHTML = '';
      const pages = data[currentSubject];
      if (pages && pages.length > 0) {
        pages.forEach((_, i) => {
          const option = document.createElement('option');
          option.value = i + 1;
          option.textContent = i + 1;
          pageSelect.appendChild(option);
        });
        currentPage = 1;
        updateViewer();
      }
    }

    function updateViewer() {
      const html = data[currentSubject][currentPage - 1];
      const blob = new Blob([html], { type: 'text/html' });
      viewer.src = URL.createObjectURL(blob);
      pageSelect.value = currentPage;
      pageInfo.textContent = "Trang " + currentPage + " / " + data[currentSubject].length;
    }

    subjectSelect.onchange = () => {
      currentSubject = subjectSelect.value;
      loadPages();
    };
    
    pageSelect.onchange = () => {
      currentPage = parseInt(pageSelect.value);
      updateViewer();
    };
    
    function prevPage() {
      if (currentPage > 1) {
        currentPage--;
        updateViewer();
      }
    }
    
    function nextPage() {
      if (currentPage < data[currentSubject].length) {
        currentPage++;
        updateViewer();
      }
    }

    loadSubjects();
  <\/script>
</body>
</html>
`;

      const blob = new Blob([html], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `tong_hop_tat_ca_mon_hoc.html`;
      a.click();
    }

    // X·ª≠ l√Ω s·ª± ki·ªán khi ch·ªçn file qua input
    fileInput.addEventListener('change', (e) => {
      const files = e.target.files;
      if (!files || files.length === 0) return;
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        let subject = 'M·∫∑c ƒë·ªãnh';
        if (file.webkitRelativePath) {
          const parts = file.webkitRelativePath.split('/');
          if (parts.length > 1) subject = parts[0];
        }
        loadFile(file, subject);
      }
      
      // Reset input ƒë·ªÉ cho ph√©p ch·ªçn l·∫°i c√πng file n·∫øu c·∫ßn
      fileInput.value = '';
    });

    updateStatus();
  </script>
</body>
</html>
